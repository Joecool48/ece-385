/*
 * background.cpp
 *
 *  Created on: Dec 3, 2018
 *      Author: joey
 */
#include "background.h"
#include "config.h"

Background_Object::Background_Object(Rect_Collider collider, bool contains_item) {
	this->collider = collider;
	this->contains_item = contains_item;
}

/*
 * TODO update current_player in constructor
 */
Background::Background() {
	// Make sure width can fit on screen on that location
	x = 0;
	y = 0;
	window_width = SCREEN_WIDTH - x;
	window_height = SCREEN_HEIGHT - y;
	deadZoneLeft = 30;
	deadZoneRight = 30;
	maxScrollSpeed = 30;
	/* TODO
	 * Initialize width and height of background.
	 * Initialize all the colliders, players, enemies, and item meta data
	 */
	screenCenterX = x + (window_width / 2); // Center starts at middle of displayable screen
	current_player = nullptr; // Most likely Mario TODO make sure this is updated with a player
}

Background::~Background() {
	// Clean up all the memory used for keeping track of screen data
	for (auto it = enemies.begin(); it != enemies.end(); it++) {
		if (it->second != nullptr)
			delete it->second;
	}
	// Draw all the items on the screen
	for (auto it = items.begin(); it != items.end(); it++) {
		if (it->second != nullptr)
			delete it->second;
	}
	// Draw all fireballs thrown by the player
	for (auto it = fireballs.begin(); it != fireballs.end(); it++) {
		if (it->second != nullptr)
			delete it->second;
	}
	// Just draw the player
	if (current_player != nullptr)
		delete current_player;
}
/*
 * TODO
 * MAKE SURE TO UPDATE THE BACKGROUND OBJECTS AS IT SCROLLS SO THAT THEY MOVE WITH IT
 */
void Background::scrollBackgroundX (int moveAmount) {
	if (screenCenterX + moveAmount - (window_width / 2) < x) {
		screenCenterX = x + (window_width / 2);
	}
	else if (screenCenterX + moveAmount + (window_width / 2) > width + x) {
		screenCenterX = x + width - (window_width / 2);
	}
	else {
		screenCenterX += moveAmount;
	}
}


void Background::drawBackground() {
	*SPRITE_X_PIO = x;
	*SPRITE_Y_PIO = y;
	// Stored column major order in memory
	*SPRITE_ADDRESS_PIO = start_address + height * (screenCenterX - (window_width / 2));
	*SPRITE_HEIGHT_PIO = height;
	*SPRITE_WIDTH_PIO = window_width;
	*SPRITE_ID_PIO = ++(*SPRITE_ID_PIO); // Make sure hardware sees change
}





/*:
 * Draws all sprites in the layer in some rendering order. Called every frame
 * Blindly updates. Doesnt check for anything
 *
 */
void Background::drawWindow() {
	drawBackground();
	// Don't need to draw background objects
	// Draw all the enemies at the current frame
	for (auto it = enemies.begin(); it != enemies.end(); it++) {
		if (it->second != nullptr)
			it->second->getCurrentSprite().drawSprite();
	}
	// Draw all the items on the screen
	for (auto it = items.begin(); it != items.end(); it++) {
		if (it->second != nullptr)
			it->second->getCurrentSprite().drawSprite();
	}
	// Draw all fireballs thrown by the player
	for (auto it = fireballs.begin(); it != fireballs.end(); it++) {
		if (it->second != nullptr)
			it->second->getCurrentSprite().drawSprite();
	}
	// Just draw the player
	if (current_player != nullptr)
		current_player->getCurrentSprite().drawSprite();
	else
		std::cout << "Player is null when trying to draw him :(" << std::endl;
}

/*
 * Returns a rect_collider if an item is a item and is touching mario. Otherwise it returns the rect default constructor
 * as a sentinel value
 */
Rect_Collider Background::itemCollidedWithPlayer() {
	// Return sentinel value if the current_player is null
	if (current_player == nullptr) return Rect_Collider();
	for (auto it = items.begin(); it != items.end();) {
		// Delete the element if it is null. Clears up some space
		if (it->second == nullptr) {
			it = items.erase(it);
		}
		else {
			if (it->second->collider.collides_with(current_player->player_collider)) return it->second->collider;
			it++;
		}
	}
	return Rect_Collider();
}

/*
 * Returns the rect_collider of the enemy that collided with the player. This logic will only determine if they hit.
 * In the player class it will determine if the player takes damage, or the enemy is killed
 */
Rect_Collider Background::enemyCollidedWithPlayer() {
	// Return sentinel value if the current_player is null
	if (current_player == nullptr) return Rect_Collider();
	for (auto it = enemies.begin(); it != enemies.end();) {
		// Delete the element if it is null. Clears up some space
		if (it->second == nullptr) {
			it = enemies.erase(it);
		}
		else {
			if (it->second->collider.collides_with(current_player->player_collider)) return it->second->collider;
			it++;
		}
	}
	return Rect_Collider();
}

void Background::setPlayer(Player *curr_player) {

}

/*
 * These two methods remove stuff in the background vector by rect_collider id.
 *
 */
void Background::removeItemById(uint64_t id) {
	if (items.find(id) != items.end()) {
		if (items[id] != nullptr) {
			delete items[id];
		}
		items.erase(id);
	}
}
void Background::removeEnemyById(uint64_t id) {
	if (enemies.find(id) != enemies.end()) {
		if (enemies[id] != nullptr) {
			delete enemies[id];
		}
		enemies.erase(id);
	}
}







